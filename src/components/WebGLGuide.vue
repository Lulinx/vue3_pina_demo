<template>
  <div class="webgl-guide">
    <div class="guide-header">
      <h1>ğŸ¨ WebGL åŸºç¡€çŸ¥è¯†å®Œæ•´æŒ‡å—</h1>
      <p class="subtitle">Webå›¾å½¢åº“ - GPUåŠ é€Ÿçš„3Då›¾å½¢æ¸²æŸ“æŠ€æœ¯</p>
    </div>

    <div class="guide-content">
      <!-- 1. WebGL ç®€ä»‹ -->
      <section class="guide-section">
        <h2>1ï¸âƒ£ ä»€ä¹ˆæ˜¯ WebGLï¼Ÿ</h2>
        <div class="content-box">
          <p><strong>WebGL (Web Graphics Library)</strong> æ˜¯ä¸€ä¸ª JavaScript APIï¼Œç”¨äºåœ¨ç½‘é¡µä¸­æ¸²æŸ“äº¤äº’å¼çš„ 3D å’Œ 2D å›¾å½¢ã€‚å®ƒåŸºäº OpenGL ES 2.0ï¼Œé€šè¿‡ GPU ç¡¬ä»¶åŠ é€Ÿå®ç°é«˜æ€§èƒ½å›¾å½¢æ¸²æŸ“ã€‚</p>

          <div class="webgl-features">
            <div class="feature-item">
              <h4>ğŸ¯ æ ¸å¿ƒç‰¹æ€§</h4>
              <ul>
                <li>âœ… GPUç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“</li>
                <li>âœ… è·¨å¹³å°å…¼å®¹æ€§</li>
                <li>âœ… ç€è‰²å™¨ç¼–ç¨‹æ”¯æŒ</li>
                <li>âœ… å®æ—¶3Då›¾å½¢æ¸²æŸ“</li>
                <li>âœ… é›¶æ’ä»¶è¿è¡Œ</li>
              </ul>
            </div>

            <div class="feature-item">
              <h4>ğŸš€ åº”ç”¨åœºæ™¯</h4>
              <ul>
                <li>ğŸ® 3Dæ¸¸æˆå¼€å‘</li>
                <li>ğŸ“Š æ•°æ®å¯è§†åŒ–</li>
                <li>ğŸ¨ åˆ›æ„ç¼–ç¨‹</li>
                <li>ğŸ—ï¸ CADæ¨¡å‹å±•ç¤º</li>
                <li>ğŸ–¼ï¸ å›¾åƒå¤„ç†</li>
                <li>ğŸ”¬ ç§‘å­¦è®¡ç®—å¯è§†åŒ–</li>
              </ul>
            </div>

            <div class="feature-item">
              <h4>âš¡ æ€§èƒ½ä¼˜åŠ¿</h4>
              <ul>
                <li>ğŸ’ª GPUå¹¶è¡Œè®¡ç®—</li>
                <li>ğŸ¯ ç¡¬ä»¶åŠ é€Ÿ</li>
                <li>ğŸ”¥ é«˜å¸§ç‡æ¸²æŸ“</li>
                <li>ğŸ“ˆ ç™¾ä¸‡é¡¶ç‚¹å¤„ç†</li>
                <li>âš™ï¸ åº•å±‚ä¼˜åŒ–</li>
              </ul>
            </div>
          </div>

          <h3>1.1 WebGL vs Canvas 2D</h3>
          <div class="comparison-table">
            <div class="comparison-item">
              <h4>Canvas 2D</h4>
              <ul>
                <li>CPUæ¸²æŸ“</li>
                <li>2Då›¾å½¢</li>
                <li>ç®€å•API</li>
                <li>æ˜“äºå­¦ä¹ </li>
                <li>æ€§èƒ½ä¸€èˆ¬</li>
              </ul>
            </div>
            <div class="comparison-item webgl-highlight">
              <h4>WebGL</h4>
              <ul>
                <li>GPUåŠ é€Ÿ</li>
                <li>2D/3Då›¾å½¢</li>
                <li>å¤æ‚API</li>
                <li>å­¦ä¹ æ›²çº¿é™¡</li>
                <li>é«˜æ€§èƒ½</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- 2. WebGL åŸºç¡€æ¦‚å¿µ -->
      <section class="guide-section">
        <h2>2ï¸âƒ£ WebGL åŸºç¡€æ¦‚å¿µ</h2>
        <div class="content-box">
          <h3>2.1 æ¸²æŸ“ç®¡çº¿ (Graphics Pipeline)</h3>
          <div class="pipeline-diagram">
            <div class="pipeline-step">
              <div class="step-number">1</div>
              <div class="step-content">
                <h4>é¡¶ç‚¹æ•°æ®</h4>
                <p>3Dæ¨¡å‹çš„é¡¶ç‚¹åæ ‡ã€æ³•çº¿ã€çº¹ç†åæ ‡ç­‰</p>
              </div>
            </div>
            <div class="arrow">â†’</div>
            <div class="pipeline-step">
              <div class="step-number">2</div>
              <div class="step-content">
                <h4>é¡¶ç‚¹ç€è‰²å™¨</h4>
                <p>å¤„ç†æ¯ä¸ªé¡¶ç‚¹çš„ä½ç½®å˜æ¢</p>
              </div>
            </div>
            <div class="arrow">â†’</div>
            <div class="pipeline-step">
              <div class="step-number">3</div>
              <div class="step-content">
                <h4>å›¾å…ƒè£…é…</h4>
                <p>å°†é¡¶ç‚¹ç»„è£…æˆä¸‰è§’å½¢ç­‰å›¾å…ƒ</p>
              </div>
            </div>
            <div class="arrow">â†’</div>
            <div class="pipeline-step">
              <div class="step-number">4</div>
              <div class="step-content">
                <h4>å‡ ä½•ç€è‰²å™¨</h4>
                <p>ç”Ÿæˆæˆ–ä¿®æ”¹å‡ ä½•å›¾å…ƒ</p>
              </div>
            </div>
            <div class="arrow">â†’</div>
            <div class="pipeline-step">
              <div class="step-number">5</div>
              <div class="step-content">
                <h4>ç‰‡æ®µç€è‰²å™¨</h4>
                <p>è®¡ç®—æ¯ä¸ªåƒç´ çš„é¢œè‰²</p>
              </div>
            </div>
            <div class="arrow">â†’</div>
            <div class="pipeline-step">
              <div class="step-number">6</div>
              <div class="step-content">
                <h4>å¸§ç¼“å†²</h4>
                <p>æœ€ç»ˆæ˜¾ç¤ºåœ¨å±å¹•ä¸Š</p>
              </div>
            </div>
          </div>

          <h3>2.2 åæ ‡ç³»ç»Ÿ</h3>
          <pre class="code-block"><code>// 1. å±€éƒ¨åæ ‡ç³» (Object Space)
// æ¨¡å‹çš„åŸå§‹åæ ‡ï¼Œç›¸å¯¹äºæ¨¡å‹ä¸­å¿ƒ

// 2. ä¸–ç•Œåæ ‡ç³» (World Space)
// é€šè¿‡æ¨¡å‹çŸ©é˜µå˜æ¢åˆ°ä¸–ç•Œåæ ‡

// 3. è§‚å¯Ÿåæ ‡ç³» (View Space)
// é€šè¿‡è§†å›¾çŸ©é˜µå˜æ¢åˆ°ç›¸æœºåæ ‡

// 4. è£å‰ªåæ ‡ç³» (Clip Space)
// é€šè¿‡æŠ•å½±çŸ©é˜µå˜æ¢åˆ°æ ‡å‡†åŒ–è®¾å¤‡åæ ‡ [-1, 1]

// 5. å±å¹•åæ ‡ç³» (Screen Space)
// æœ€ç»ˆçš„åƒç´ åæ ‡

// åæ ‡å˜æ¢æµç¨‹
const modelMatrix = mat4.create();      // æ¨¡å‹å˜æ¢
const viewMatrix = mat4.create();       // è§†å›¾å˜æ¢
const projectionMatrix = mat4.create(); // æŠ•å½±å˜æ¢

// MVPçŸ©é˜µ = æŠ•å½±çŸ©é˜µ Ã— è§†å›¾çŸ©é˜µ Ã— æ¨¡å‹çŸ©é˜µ
const mvpMatrix = mat4.create();
mat4.multiply(mvpMatrix, projectionMatrix, viewMatrix);
mat4.multiply(mvpMatrix, mvpMatrix, modelMatrix);</code></pre>

          <h3>2.3 ç€è‰²å™¨è¯­è¨€ (GLSL)</h3>
          <div class="shader-example">
            <h4>é¡¶ç‚¹ç€è‰²å™¨ç¤ºä¾‹ï¼š</h4>
            <pre class="code-block"><code>// é¡¶ç‚¹ç€è‰²å™¨ (Vertex Shader)
attribute vec3 a_position;    // é¡¶ç‚¹ä½ç½®å±æ€§
attribute vec2 a_texCoord;   // çº¹ç†åæ ‡å±æ€§
uniform mat4 u_mvpMatrix;    // MVPå˜æ¢çŸ©é˜µ
varying vec2 v_texCoord;     // ä¼ é€’ç»™ç‰‡æ®µç€è‰²å™¨çš„å˜é‡

void main() {
    // å˜æ¢é¡¶ç‚¹ä½ç½®
    gl_Position = u_mvpMatrix * vec4(a_position, 1.0);

    // ä¼ é€’çº¹ç†åæ ‡
    v_texCoord = a_texCoord;
}</code></pre>

            <h4>ç‰‡æ®µç€è‰²å™¨ç¤ºä¾‹ï¼š</h4>
            <pre class="code-block"><code>// ç‰‡æ®µç€è‰²å™¨ (Fragment Shader)
precision mediump float;
uniform sampler2D u_texture;  // çº¹ç†é‡‡æ ·å™¨
uniform vec3 u_lightColor;    // å…‰ç…§é¢œè‰²
varying vec2 v_texCoord;      // ä»é¡¶ç‚¹ç€è‰²å™¨æ¥æ”¶çš„çº¹ç†åæ ‡

void main() {
    // é‡‡æ ·çº¹ç†é¢œè‰²
    vec4 texColor = texture2D(u_texture, v_texCoord);

    // åº”ç”¨å…‰ç…§
    vec3 finalColor = texColor.rgb * u_lightColor;

    // è¾“å‡ºæœ€ç»ˆé¢œè‰²
    gl_FragColor = vec4(finalColor, texColor.a);
}</code></pre>
          </div>
        </div>
      </section>

      <!-- 3. WebGL ç¼–ç¨‹åŸºç¡€ -->
      <section class="guide-section">
        <h2>3ï¸âƒ£ WebGL ç¼–ç¨‹åŸºç¡€</h2>
        <div class="content-box">
          <h3>3.1 åˆå§‹åŒ– WebGL ä¸Šä¸‹æ–‡</h3>
          <pre class="code-block"><code>// 1. è·å–canvaså…ƒç´ 
const canvas = document.getElementById('webgl-canvas');

// 2. è·å–WebGLä¸Šä¸‹æ–‡
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
    alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGL');
    return;
}

// 3. è®¾ç½®è§†å£
gl.viewport(0, 0, canvas.width, canvas.height);

// 4. è®¾ç½®æ¸…é™¤é¢œè‰²
gl.clearColor(0.0, 0.0, 0.0, 1.0);

// 5. å¼€å¯æ·±åº¦æµ‹è¯•
gl.enable(gl.DEPTH_TEST);

// 6. æ¸…é™¤ç¼“å†²åŒº
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</code></pre>

          <h3>3.2 åˆ›å»ºå’Œç¼–è¯‘ç€è‰²å™¨</h3>
          <pre class="code-block"><code>// åˆ›å»ºç€è‰²å™¨å‡½æ•°
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    // æ£€æŸ¥ç¼–è¯‘çŠ¶æ€
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('ç€è‰²å™¨ç¼–è¯‘å¤±è´¥:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

// åˆ›å»ºç€è‰²å™¨ç¨‹åº
function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    // æ£€æŸ¥é“¾æ¥çŠ¶æ€
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('ç€è‰²å™¨ç¨‹åºé“¾æ¥å¤±è´¥:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
    }

    return program;
}

// ä½¿ç”¨ç¤ºä¾‹
const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vertexShader, fragmentShader);

gl.useProgram(program);</code></pre>

          <h3>3.3 ç¼“å†²åŒºå¯¹è±¡ (Buffer)</h3>
          <pre class="code-block"><code>// 1. åˆ›å»ºç¼“å†²åŒº
const vertexBuffer = gl.createBuffer();

// 2. ç»‘å®šç¼“å†²åŒº
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

// 3. å†™å…¥æ•°æ®
const vertices = new Float32Array([
    -0.5, -0.5, 0.0,  // ç¬¬ä¸€ä¸ªé¡¶ç‚¹
     0.5, -0.5, 0.0,  // ç¬¬äºŒä¸ªé¡¶ç‚¹
     0.0,  0.5, 0.0   // ç¬¬ä¸‰ä¸ªé¡¶ç‚¹
]);

gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

// 4. è·å–å±æ€§ä½ç½®
const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');

// 5. å¯ç”¨å±æ€§
gl.enableVertexAttribArray(positionAttributeLocation);

// 6. æŒ‡å®šå±æ€§æ ¼å¼
gl.vertexAttribPointer(
    positionAttributeLocation, // å±æ€§ä½ç½®
    3,                        // æ¯ä¸ªé¡¶ç‚¹çš„åˆ†é‡æ•°
    gl.FLOAT,                 // æ•°æ®ç±»å‹
    false,                    // æ˜¯å¦å½’ä¸€åŒ–
    0,                        // æ­¥é•¿
    0                         // åç§»
);</code></pre>

          <h3>3.4 ç»˜åˆ¶åŸºæœ¬å›¾å½¢</h3>
          <pre class="code-block"><code>// ç»˜åˆ¶ä¸‰è§’å½¢
function drawTriangle() {
    // è®¾ç½®é¡¶ç‚¹æ•°æ®
    const vertices = new Float32Array([
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    ]);

    // åˆ›å»ºç¼“å†²åŒºå¹¶å†™å…¥æ•°æ®
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    // è·å–å±æ€§ä½ç½®å¹¶è®¾ç½®
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

    // ç»˜åˆ¶
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}

// ç»˜åˆ¶çŸ©å½¢ï¼ˆä¸¤ä¸ªä¸‰è§’å½¢ï¼‰
function drawRectangle() {
    const vertices = new Float32Array([
        -0.5, -0.5, 0.0,  // å·¦ä¸‹
         0.5, -0.5, 0.0,  // å³ä¸‹
         0.5,  0.5, 0.0,  // å³ä¸Š
        -0.5,  0.5, 0.0   // å·¦ä¸Š
    ]);

    const indices = new Uint16Array([
        0, 1, 2,  // ç¬¬ä¸€ä¸ªä¸‰è§’å½¢
        0, 2, 3   // ç¬¬äºŒä¸ªä¸‰è§’å½¢
    ]);

    // é¡¶ç‚¹ç¼“å†²åŒº
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    // ç´¢å¼•ç¼“å†²åŒº
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

    // ä½¿ç”¨ç´¢å¼•ç»˜åˆ¶
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}</code></pre>
        </div>
      </section>

      <!-- 4. å˜æ¢å’ŒçŸ©é˜µ -->
      <section class="guide-section">
        <h2>4ï¸âƒ£ å˜æ¢å’ŒçŸ©é˜µ</h2>
        <div class="content-box">
          <h3>4.1 åŸºç¡€å˜æ¢çŸ©é˜µ</h3>
          <pre class="code-block"><code>// 1. ä½ç§»çŸ©é˜µ (Translation)
function createTranslationMatrix(tx, ty, tz) {
    return [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        tx, ty, tz, 1
    ];
}

// 2. ç¼©æ”¾çŸ©é˜µ (Scale)
function createScaleMatrix(sx, sy, sz) {
    return [
        sx, 0,  0,  0,
        0,  sy, 0,  0,
        0,  0,  sz, 0,
        0,  0,  0,  1
    ];
}

// 3. æ—‹è½¬çŸ©é˜µ (Rotation around Z-axis)
function createRotationZMatrix(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    return [
        c, -s, 0, 0,
        s,  c, 0, 0,
        0,  0,  1, 0,
        0,  0,  0,  1
    ];
}

// 4. çŸ©é˜µä¹˜æ³•
function multiplyMatrices(a, b) {
    const result = new Array(16);
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            result[i * 4 + j] = 0;
            for (let k = 0; k < 4; k++) {
                result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
            }
        }
    }
    return result;
}

// 5. åº”ç”¨å˜æ¢
const translation = createTranslationMatrix(1, 2, 0);
const scale = createScaleMatrix(2, 2, 1);
const rotation = createRotationZMatrix(Math.PI / 4);

// ç»„åˆå˜æ¢ (æ³¨æ„é¡ºåºï¼šç¼©æ”¾ â†’ æ—‹è½¬ â†’ ä½ç§»)
const transform = multiplyMatrices(translation,
    multiplyMatrices(rotation, scale));

// ä¼ é€’ç»™ç€è‰²å™¨
const matrixLocation = gl.getUniformLocation(program, 'u_transform');
gl.uniformMatrix4fv(matrixLocation, false, transform);</code></pre>

          <h3>4.2 æŠ•å½±çŸ©é˜µ</h3>
          <pre class="code-block"><code>// æ­£äº¤æŠ•å½±çŸ©é˜µ (Orthographic Projection)
function createOrthographicMatrix(left, right, bottom, top, near, far) {
    const width = right - left;
    const height = top - bottom;
    const depth = far - near;

    return [
        2/width, 0, 0, 0,
        0, 2/height, 0, 0,
        0, 0, -2/depth, 0,
        -(right+left)/width, -(top+bottom)/height, -(far+near)/depth, 1
    ];
}

// é€è§†æŠ•å½±çŸ©é˜µ (Perspective Projection)
function createPerspectiveMatrix(fov, aspect, near, far) {
    const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
    const rangeInv = 1.0 / (near - far);

    return [
        f/aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (near + far) * rangeInv, -1,
        0, 0, near * far * rangeInv * 2, 0
    ];
}

// è§†å›¾çŸ©é˜µ (Look-At)
function createLookAtMatrix(eye, target, up) {
    const zAxis = normalize(subtract(eye, target));
    const xAxis = normalize(cross(up, zAxis));
    const yAxis = cross(zAxis, xAxis);

    return [
        xAxis[0], yAxis[0], zAxis[0], 0,
        xAxis[1], yAxis[1], zAxis[1], 0,
        xAxis[2], yAxis[2], zAxis[2], 0,
        -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
    ];
}

// ä½¿ç”¨ç¤ºä¾‹
const projectionMatrix = createPerspectiveMatrix(
    Math.PI / 4,    // 45åº¦è§†é‡
    canvas.width / canvas.height,  // å®½é«˜æ¯”
    0.1,            // è¿‘è£å‰ªé¢
    100             // è¿œè£å‰ªé¢
);

const viewMatrix = createLookAtMatrix(
    [0, 0, 5],      // ç›¸æœºä½ç½®
    [0, 0, 0],      // ç›®æ ‡ä½ç½®
    [0, 1, 0]       // ä¸Šæ–¹å‘
);

// MVPçŸ©é˜µ
const mvpMatrix = multiplyMatrices(projectionMatrix,
    multiplyMatrices(viewMatrix, modelMatrix));</code></pre>
        </div>
      </section>

      <!-- 5. çº¹ç†å’Œæè´¨ -->
      <section class="guide-section">
        <h2>5ï¸âƒ£ çº¹ç†å’Œæè´¨</h2>
        <div class="content-box">
          <h3>5.1 åŠ è½½å’Œä½¿ç”¨çº¹ç†</h3>
          <pre class="code-block"><code>// 1. åˆ›å»ºçº¹ç†å¯¹è±¡
function createTexture(gl, image) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // è®¾ç½®çº¹ç†å‚æ•°
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    // ä¸Šä¼ çº¹ç†æ•°æ®
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

    return texture;
}

// 2. å¼‚æ­¥åŠ è½½çº¹ç†
function loadTexture(gl, url) {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.crossOrigin = 'anonymous';

        image.onload = () => {
            const texture = createTexture(gl, image);
            resolve(texture);
        };

        image.onerror = reject;
        image.src = url;
    });
}

// 3. ä½¿ç”¨çº¹ç†
async function initTextures() {
    try {
        const texture1 = await loadTexture(gl, 'texture1.jpg');
        const texture2 = await loadTexture(gl, 'texture2.png');

        // æ¿€æ´»çº¹ç†å•å…ƒ
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture1);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, texture2);

        // ä¼ é€’çº¹ç†å•å…ƒç»™ç€è‰²å™¨
        const textureLocation1 = gl.getUniformLocation(program, 'u_texture1');
        gl.uniform1i(textureLocation1, 0); // çº¹ç†å•å…ƒ 0

        const textureLocation2 = gl.getUniformLocation(program, 'u_texture2');
        gl.uniform1i(textureLocation2, 1); // çº¹ç†å•å…ƒ 1

    } catch (error) {
        console.error('çº¹ç†åŠ è½½å¤±è´¥:', error);
    }
}</code></pre>

          <h3>5.2 çº¹ç†åæ ‡ç³»</h3>
          <div class="texture-coords">
            <div class="coord-example">
              <pre class="code-block"><code>// çº¹ç†åæ ‡ (UVåæ ‡)
// (0,0) å·¦ä¸Šè§’
// (1,0) å³ä¸Šè§’
// (1,1) å³ä¸‹è§’
// (0,1) å·¦ä¸‹è§’

const textureCoords = new Float32Array([
    0.0, 0.0,  // å·¦ä¸Š
    1.0, 0.0,  // å³ä¸Š
    1.0, 1.0,  // å³ä¸‹
    0.0, 1.0   // å·¦ä¸‹
]);

// åœ¨ç‰‡æ®µç€è‰²å™¨ä¸­ä½¿ç”¨
varying vec2 v_texCoord;
uniform sampler2D u_texture;

void main() {
    vec4 texColor = texture2D(u_texture, v_texCoord);
    gl_FragColor = texColor;
}</code></pre>
            </div>
            <div class="coord-diagram">
              <div class="texture-grid">
                <div class="grid-point">(0,0)</div>
                <div class="grid-point">(1,0)</div>
                <div class="grid-point">(0,1)</div>
                <div class="grid-point">(1,1)</div>
              </div>
            </div>
          </div>

          <h3>5.3 å¤šé‡çº¹ç†å’Œæ··åˆ</h3>
          <pre class="code-block"><code>// ç‰‡æ®µç€è‰²å™¨ - å¤šé‡çº¹ç†æ··åˆ
precision mediump float;

uniform sampler2D u_texture1;
uniform sampler2D u_texture2;
uniform float u_mixRatio;

varying vec2 v_texCoord;

void main() {
    // é‡‡æ ·ä¸¤ä¸ªçº¹ç†
    vec4 color1 = texture2D(u_texture1, v_texCoord);
    vec4 color2 = texture2D(u_texture2, v_texCoord);

    // çº¿æ€§æ··åˆ
    vec4 finalColor = mix(color1, color2, u_mixRatio);

    // æ·»åŠ é€æ˜åº¦æ··åˆ
    finalColor.a = color1.a * color2.a;

    gl_FragColor = finalColor;
}

// JavaScript ä¸­æ§åˆ¶æ··åˆæ¯”ä¾‹
const mixRatioLocation = gl.getUniformLocation(program, 'u_mixRatio');
let mixRatio = 0.5;

function animate() {
    mixRatio += 0.01;
    if (mixRatio > 1.0) mixRatio = 0.0;

    gl.uniform1f(mixRatioLocation, mixRatio);
    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

    requestAnimationFrame(animate);
}

animate();</code></pre>
        </div>
      </section>

      <!-- 6. å…‰ç…§å’Œæè´¨ -->
      <section class="guide-section">
        <h2>6ï¸âƒ£ å…‰ç…§å’Œæè´¨</h2>
        <div class="content-box">
          <h3>6.1 åŸºç¡€å…‰ç…§æ¨¡å‹</h3>
          <pre class="code-block"><code>// ç‰‡æ®µç€è‰²å™¨ - Phongå…‰ç…§æ¨¡å‹
precision mediump float;

struct Light {
    vec3 position;
    vec3 color;
    float intensity;
};

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

uniform Light u_light;
uniform Material u_material;
uniform vec3 u_viewPosition;

varying vec3 v_position;
varying vec3 v_normal;

void main() {
    // ç¯å¢ƒå…‰
    vec3 ambient = u_light.color * u_material.ambient * u_light.intensity;

    // æ¼«åå°„
    vec3 norm = normalize(v_normal);
    vec3 lightDir = normalize(u_light.position - v_position);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = u_light.color * u_material.diffuse * diff * u_light.intensity;

    // é•œé¢åå°„
    vec3 viewDir = normalize(u_viewPosition - v_position);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_material.shininess);
    vec3 specular = u_light.color * u_material.specular * spec * u_light.intensity;

    // æœ€ç»ˆé¢œè‰²
    vec3 result = ambient + diffuse + specular;
    gl_FragColor = vec4(result, 1.0);
}</code></pre>

          <h3>6.2 æ³•å‘é‡å’Œå˜æ¢</h3>
          <pre class="code-block"><code>// 1. æ³•å‘é‡å˜æ¢çŸ©é˜µ (Normal Matrix)
// å¯¹äºéå‡åŒ€ç¼©æ”¾ï¼Œéœ€è¦ä½¿ç”¨æ³•å‘é‡çŸ©é˜µ

// æ³•å‘é‡çŸ©é˜µ = (æ¨¡å‹çŸ©é˜µçš„é€†çŸ©é˜µ)çš„è½¬ç½®
function createNormalMatrix(modelMatrix) {
    const normalMatrix = mat4.create();
    mat4.invert(normalMatrix, modelMatrix);
    mat4.transpose(normalMatrix, normalMatrix);
    return normalMatrix;
}

// 2. åœ¨ç€è‰²å™¨ä¸­åº”ç”¨æ³•å‘é‡å˜æ¢
// é¡¶ç‚¹ç€è‰²å™¨
attribute vec3 a_normal;
uniform mat4 u_normalMatrix;

varying vec3 v_normal;

void main() {
    // å˜æ¢æ³•å‘é‡ (ä½¿ç”¨æ³•å‘é‡çŸ©é˜µ)
    v_normal = mat3(u_normalMatrix) * a_normal;

    // å…¶ä»–é¡¶ç‚¹å˜æ¢...
    gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
}

// 3. å¤šå…‰æºå…‰ç…§
struct DirectionalLight {
    vec3 direction;
    vec3 color;
    float intensity;
};

struct PointLight {
    vec3 position;
    vec3 color;
    float intensity;
    float constant;
    float linear;
    float quadratic;
};

uniform DirectionalLight u_directionalLights[4];
uniform PointLight u_pointLights[8];

vec3 calculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDir) {
    vec3 lightDir = normalize(-light.direction);
    float diff = max(dot(normal, lightDir), 0.0);
    return light.color * light.intensity * diff;
}

vec3 calculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir) {
    vec3 lightDir = normalize(light.position - fragPos);
    float diff = max(dot(normal, lightDir), 0.0);

    // è·ç¦»è¡°å‡
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance +
                               light.quadratic * distance * distance);

    return light.color * light.intensity * diff * attenuation;
}</code></pre>
        </div>
      </section>

      <!-- 7. é«˜çº§æŠ€æœ¯ -->
      <section class="guide-section">
        <h2>7ï¸âƒ£ é«˜çº§æŠ€æœ¯</h2>
        <div class="content-box">
          <h3>7.1 å¸§ç¼“å†²åŒºå¯¹è±¡ (FBO)</h3>
          <pre class="code-block"><code>// åˆ›å»ºç¦»å±æ¸²æŸ“ç›®æ ‡
function createFramebuffer(gl, width, height) {
    // åˆ›å»ºå¸§ç¼“å†²åŒº
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

    // åˆ›å»ºçº¹ç†é™„ä»¶
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
                  gl.RGBA, gl.UNSIGNED_BYTE, null);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    // é™„åŠ åˆ°å¸§ç¼“å†²åŒº
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                           gl.TEXTURE_2D, texture, 0);

    // åˆ›å»ºæ·±åº¦ç¼“å†²åŒº
    const depthBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
                              gl.RENDERBUFFER, depthBuffer);

    // æ£€æŸ¥å¸§ç¼“å†²åŒºå®Œæ•´æ€§
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        console.error('å¸§ç¼“å†²åŒºåˆ›å»ºå¤±è´¥');
        return null;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return { framebuffer, texture, depthBuffer };
}

// åå¤„ç†æ•ˆæœç¤ºä¾‹ï¼šæ¨¡ç³Š
function applyBlurEffect(originalTexture, blurTexture) {
    // ç¬¬ä¸€éï¼šæ°´å¹³æ¨¡ç³Š
    gl.bindFramebuffer(gl.FRAMEBUFFER, blurFBO);
    gl.useProgram(horizontalBlurProgram);
    gl.bindTexture(gl.TEXTURE_2D, originalTexture);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // ç¬¬äºŒéï¼šå‚ç›´æ¨¡ç³Š
    gl.bindFramebuffer(gl.FRAMEBUFFER, null); // æ¸²æŸ“åˆ°å±å¹•
    gl.useProgram(verticalBlurProgram);
    gl.bindTexture(gl.TEXTURE_2D, blurTexture);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}</code></pre>

          <h3>7.2 WebGL 2.0 æ–°ç‰¹æ€§</h3>
          <pre class="code-block"><code>// 1. é¡¶ç‚¹æ•°ç»„å¯¹è±¡ (VAO)
function createVAO(gl, program, attributes) {
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    // è®¾ç½®æ‰€æœ‰å±æ€§
    for (const attr of attributes) {
        const location = gl.getAttribLocation(program, attr.name);
        gl.enableVertexAttribArray(location);

        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
        gl.vertexAttribPointer(location, attr.size, gl.FLOAT, false, 0, 0);
    }

    gl.bindVertexArray(null);
    return vao;
}

// 2. ç»Ÿä¸€ç¼“å†²åŒºå¯¹è±¡ (UBO)
function createUBO(gl, blockName, program, data) {
    const blockIndex = gl.getUniformBlockIndex(program, blockName);
    const blockSize = gl.getActiveUniformBlockParameter(program, blockIndex,
                                                       gl.UNIFORM_BLOCK_DATA_SIZE);

    const ubo = gl.createBuffer();
    gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
    gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);

    // ç»‘å®šåˆ°ç»‘å®šç‚¹
    gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, ubo);
    gl.uniformBlockBinding(program, blockIndex, 0);

    return ubo;
}

// 3. å¤šé‡æ¸²æŸ“ç›®æ ‡ (MRT)
function setupMRT(gl) {
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

    // åˆ›å»ºå¤šä¸ªé¢œè‰²é™„ä»¶
    const textures = [];
    for (let i = 0; i < 4; i++) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
                      gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.framebufferTexture2D(gl.FRAMEBUFFER,
                               gl.COLOR_ATTACHMENT0 + i,
                               gl.TEXTURE_2D, texture, 0);
        textures.push(texture);
    }

    // æŒ‡å®šè¦å†™å…¥çš„é¢œè‰²é™„ä»¶
    gl.drawBuffers([
        gl.COLOR_ATTACHMENT0,
        gl.COLOR_ATTACHMENT1,
        gl.COLOR_ATTACHMENT2,
        gl.COLOR_ATTACHMENT3
    ]);

    return { framebuffer, textures };
}</code></pre>

          <h3>7.3 æ€§èƒ½ä¼˜åŒ–æŠ€å·§</h3>
          <div class="optimization-tips">
            <div class="tip-group">
              <h4>ğŸ¯ æ¸²æŸ“ä¼˜åŒ–</h4>
              <ul>
                <li><strong>æ‰¹é‡ç»˜åˆ¶ï¼š</strong>å‡å°‘ draw callï¼Œä½¿ç”¨å®ä¾‹åŒ–æ¸²æŸ“</li>
                <li><strong>LODï¼š</strong>è·ç¦»è¶Šè¿œï¼Œç»†èŠ‚è¶Šå°‘</li>
                <li><strong>è§†é”¥å‰”é™¤ï¼š</strong>åªæ¸²æŸ“å¯è§å¯¹è±¡</li>
                <li><strong>é®æŒ¡å‰”é™¤ï¼š</strong>è¢«é®æŒ¡çš„å¯¹è±¡ä¸æ¸²æŸ“</li>
              </ul>
            </div>

            <div class="tip-group">
              <h4>ğŸ’¾ å†…å­˜ä¼˜åŒ–</h4>
              <ul>
                <li><strong>çº¹ç†å‹ç¼©ï¼š</strong>ä½¿ç”¨å‹ç¼©çº¹ç†æ ¼å¼</li>
                <li><strong>å¯¹è±¡æ± ï¼š</strong>å¤ç”¨å‡ ä½•ä½“å’Œæè´¨</li>
                <li><strong>åƒåœ¾å›æ”¶ï¼š</strong>åŠæ—¶æ¸…ç†ä¸å†ä½¿ç”¨çš„èµ„æº</li>
                <li><strong>æµå¼åŠ è½½ï¼š</strong>æŒ‰éœ€åŠ è½½èµ„æº</li>
              </ul>
            </div>

            <div class="tip-group">
              <h4>âš¡ GPUä¼˜åŒ–</h4>
              <ul>
                <li><strong>ç€è‰²å™¨ä¼˜åŒ–ï¼š</strong>å‡å°‘è®¡ç®—å¤æ‚åº¦</li>
                <li><strong>æ•°æ®ç²¾åº¦ï¼š</strong>åˆç†ä½¿ç”¨ float/half</li>
                <li><strong>åˆ†æ”¯é¿å…ï¼š</strong>å‡å°‘æ¡ä»¶è¯­å¥</li>
                <li><strong>çº¹ç†é‡‡æ ·ï¼š</strong>ä¼˜åŒ–çº¹ç†è®¿é—®æ¨¡å¼</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- 8. å¸¸ç”¨åº“å’Œæ¡†æ¶ -->
      <section class="guide-section">
        <h2>8ï¸âƒ£ å¸¸ç”¨åº“å’Œæ¡†æ¶</h2>
        <div class="content-box">
          <div class="library-grid">
            <div class="library-item">
              <h4>ğŸ¯ Three.js</h4>
              <p>3D JavaScriptåº“ï¼Œå°è£…äº†WebGLçš„å¤æ‚æ€§</p>
              <ul>
                <li>âœ… ç®€åŒ–çš„3D API</li>
                <li>âœ… ä¸°å¯Œçš„å‡ ä½•ä½“å’Œæè´¨</li>
                <li>âœ… å†…ç½®åŠ¨ç”»ç³»ç»Ÿ</li>
                <li>âœ… å¼ºå¤§çš„æ’ä»¶ç”Ÿæ€</li>
              </ul>
            </div>

            <div class="library-item">
              <h4>ğŸ¨ Babylon.js</h4>
              <p>ç°ä»£åŒ–çš„WebGLæ¸¸æˆå¼•æ“</p>
              <ul>
                <li>âœ… å®Œæ•´çš„æ¸¸æˆå¼•æ“åŠŸèƒ½</li>
                <li>âœ… ç‰©ç†å¼•æ“é›†æˆ</li>
                <li>âœ… PBRæè´¨ç³»ç»Ÿ</li>
                <li>âœ… éŸ³é¢‘ç³»ç»Ÿæ”¯æŒ</li>
              </ul>
            </div>

            <div class="library-item">
              <h4>ğŸš€ PlayCanvas</h4>
              <p>åŸºäºWebGLçš„3Dæ¸¸æˆå¼•æ“</p>
              <ul>
                <li>âœ… å¯è§†åŒ–ç¼–è¾‘å™¨</li>
                <li>âœ… å®æ—¶åä½œ</li>
                <li>âœ… å¼ºå¤§çš„å›¾å½¢ç®¡çº¿</li>
                <li>âœ… äº‘ç«¯å‘å¸ƒ</li>
              </ul>
            </div>

            <div class="library-item">
              <h4>ğŸª A-Frame</h4>
              <p>åŸºäºThree.jsçš„WebVRæ¡†æ¶</p>
              <ul>
                <li>âœ… å£°æ˜å¼è¯­æ³•</li>
                <li>âœ… VR/ARæ”¯æŒ</li>
                <li>âœ… ç»„ä»¶åŒ–æ¶æ„</li>
                <li>âœ… å®ä½“-ç»„ä»¶ç³»ç»Ÿ</li>
              </ul>
            </div>

            <div class="library-item">
              <h4>ğŸ§° gl-matrix</h4>
              <p>é«˜æ€§èƒ½çš„JavaScriptçŸ©é˜µè¿ç®—åº“</p>
              <ul>
                <li>âœ… ä¼˜åŒ–çš„çŸ©é˜µè¿ç®—</li>
                <li>âœ… æ”¯æŒå‘é‡å’Œå››å…ƒæ•°</li>
                <li>âœ… å…¼å®¹WebGL</li>
                <li>âœ… TypeScriptæ”¯æŒ</li>
              </ul>
            </div>

            <div class="library-item">
              <h4>ğŸ­ Regl</h4>
              <p>å‡½æ•°å¼WebGLç¼–ç¨‹æ¡†æ¶</p>
              <ul>
                <li>âœ… å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼</li>
                <li>âœ… è‡ªåŠ¨èµ„æºç®¡ç†</li>
                <li>âœ… ç®€åŒ–çš„APIè®¾è®¡</li>
                <li>âœ… ä¼˜ç§€çš„æ€§èƒ½</li>
              </ul>
            </div>
          </div>

          <h3>Three.js å¿«é€Ÿä¸Šæ‰‹</h3>
          <pre class="code-block"><code>// 1. åŸºæœ¬åœºæ™¯è®¾ç½®
import * as THREE from 'three';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 2. åˆ›å»ºå‡ ä½•ä½“
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);

scene.add(cube);

// 3. è®¾ç½®ç›¸æœºä½ç½®
camera.position.z = 5;

// 4. æ¸²æŸ“å¾ªç¯
function animate() {
    requestAnimationFrame(animate);

    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;

    renderer.render(scene, camera);
}

animate();</code></pre>
        </div>
      </section>

      <!-- 9. æœ€ä½³å®è·µå’Œè°ƒè¯• -->
      <section class="guide-section">
        <h2>9ï¸âƒ£ æœ€ä½³å®è·µå’Œè°ƒè¯•</h2>
        <div class="content-box">
          <h3>9.1 é”™è¯¯å¤„ç†å’Œè°ƒè¯•</h3>
          <pre class="code-block"><code>// 1. WebGLä¸Šä¸‹æ–‡ä¸¢å¤±å¤„ç†
canvas.addEventListener('webglcontextlost', function(event) {
    console.warn('WebGL context lost');
    event.preventDefault();

    // æ¸…ç†èµ„æº
    cleanupResources();

    // å°è¯•æ¢å¤
    setTimeout(() => {
        initWebGL();
    }, 1000);
});

canvas.addEventListener('webglcontextrestored', function(event) {
    console.log('WebGL context restored');
    initWebGL();
});

// 2. ç€è‰²å™¨ç¼–è¯‘é”™è¯¯æ£€æŸ¥
function checkShaderError(gl, shader, source) {
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(shader);
        console.error('ç€è‰²å™¨ç¼–è¯‘é”™è¯¯:', error);

        // æ˜¾ç¤ºé”™è¯¯çš„æºä»£ç è¡Œ
        const lines = source.split('\n');
        const errorLines = error.match(/ERROR: \d+:(\d+)/g);
        if (errorLines) {
            errorLines.forEach(match => {
                const lineNum = match.match(/\d+/)[0];
                console.log(`ç¬¬${lineNum}è¡Œ:`, lines[lineNum - 1]);
            });
        }

        return false;
    }
    return true;
}

// 3. æ€§èƒ½ç›‘æ§
class WebGLProfiler {
    constructor(gl) {
        this.gl = gl;
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
    }

    beginFrame() {
        this.frameStart = performance.now();
    }

    endFrame() {
        const frameTime = performance.now() - this.frameStart;
        this.frameCount++;

        if (this.frameCount >= 60) {
            this.fps = 1000 / (performance.now() - this.lastTime) * 60;
            this.frameCount = 0;
            this.lastTime = performance.now();
        }

        // æ£€æŸ¥WebGLé”™è¯¯
        const error = this.gl.getError();
        if (error !== this.gl.NO_ERROR) {
            console.error('WebGL Error:', this.getErrorString(error));
        }
    }

    getErrorString(error) {
        switch(error) {
            case this.gl.INVALID_ENUM: return 'INVALID_ENUM';
            case this.gl.INVALID_VALUE: return 'INVALID_VALUE';
            case this.gl.INVALID_OPERATION: return 'INVALID_OPERATION';
            case this.gl.OUT_OF_MEMORY: return 'OUT_OF_MEMORY';
            default: return 'UNKNOWN_ERROR';
        }
    }
}</code></pre>

          <h3>9.2 æµè§ˆå™¨å…¼å®¹æ€§å¤„ç†</h3>
          <pre class="code-block"><code>// 1. æ£€æµ‹WebGLæ”¯æŒ
function detectWebGL() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') ||
              canvas.getContext('experimental-webgl');

    if (!gl) {
        return {
            supported: false,
            reason: 'æµè§ˆå™¨ä¸æ”¯æŒWebGL'
        };
    }

    // æ£€æŸ¥æ‰©å±•æ”¯æŒ
    const extensions = {
        'OES_texture_float': gl.getExtension('OES_texture_float'),
        'WEBGL_draw_buffers': gl.getExtension('WEBGL_draw_buffers'),
        'OES_standard_derivatives': gl.getExtension('OES_standard_derivatives')
    };

    // æ£€æŸ¥æœ€å¤§çº¹ç†å°ºå¯¸
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

    // æ£€æŸ¥é¡¶ç‚¹ç€è‰²å™¨æœ€å¤§uniformæ•°é‡
    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);

    return {
        supported: true,
        extensions,
        maxTextureSize,
        maxVertexUniforms,
        renderer: gl.getParameter(gl.RENDERER),
        version: gl.getParameter(gl.VERSION)
    };
}

// 2. ä¼˜é›…é™çº§
async function initWebGL() {
    const webglInfo = detectWebGL();

    if (!webglInfo.supported) {
        // æ˜¾ç¤ºé™çº§UI
        showFallbackUI(webglInfo.reason);
        return;
    }

    try {
        await loadShaders();
        await loadTextures();
        setupScene();
        startRenderLoop();
    } catch (error) {
        console.error('WebGLåˆå§‹åŒ–å¤±è´¥:', error);
        showFallbackUI('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
    }
}

// 3. å†…å­˜ç®¡ç†
class ResourceManager {
    constructor(gl) {
        this.gl = gl;
        this.resources = new Set();
    }

    track(resource, type) {
        this.resources.add({ resource, type });
    }

    dispose(resource, type) {
        switch(type) {
            case 'buffer':
                this.gl.deleteBuffer(resource);
                break;
            case 'texture':
                this.gl.deleteTexture(resource);
                break;
            case 'program':
                this.gl.deleteProgram(resource);
                break;
            case 'framebuffer':
                this.gl.deleteFramebuffer(resource);
                break;
        }
        this.resources.delete(resource);
    }

    disposeAll() {
        for (const { resource, type } of this.resources) {
            this.dispose(resource, type);
        }
        this.resources.clear();
    }
}</code></pre>

          <h3>9.3 ç§»åŠ¨ç«¯ä¼˜åŒ–</h3>
          <ul>
            <li><strong>çº¹ç†å‹ç¼©ï¼š</strong>ä½¿ç”¨ETC1/ETC2/PVRTCæ ¼å¼</li>
            <li><strong>ç€è‰²å™¨ç®€åŒ–ï¼š</strong>å‡å°‘è®¡ç®—å¤æ‚åº¦ï¼Œåˆå¹¶çº¹ç†é‡‡æ ·</li>
            <li><strong>å‡ ä½•ä½“ä¼˜åŒ–ï¼š</strong>ä½¿ç”¨ç´¢å¼•ç¼“å†²åŒºï¼Œå‡å°‘é¡¶ç‚¹æ•°é‡</li>
            <li><strong>æ¸²æŸ“åˆ†è¾¨ç‡ï¼š</strong>æ ¹æ®è®¾å¤‡åƒç´ æ¯”è°ƒæ•´</li>
            <li><strong>ç”µæ± ä¼˜åŒ–ï¼š</strong>é™ä½å¸§ç‡ï¼Œå‡å°‘GPUè´Ÿè½½</li>
          </ul>
        </div>
      </section>
    </div>
  </div>
</template>

<script setup>
// WebGL åŸºç¡€çŸ¥è¯†è®²è§£ç»„ä»¶
</script>

<style scoped>
.webgl-guide {
  background: white;
  padding: 20px;
  min-height: 100%;
  height: 100%;
  overflow-y: auto;
}

.guide-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 30px;
  border-radius: 12px;
  margin-bottom: 30px;
}

.guide-header h1 {
  font-size: 2rem;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.guide-header .subtitle {
  font-size: 1.1rem;
  opacity: 0.9;
  margin-bottom: 0;
}

.guide-content {
  padding: 0;
}

.guide-section {
  margin-bottom: 40px;
  border-bottom: 2px solid #f0f0f0;
  padding-bottom: 30px;
}

.guide-section:last-child {
  border-bottom: none;
}

.guide-section h2 {
  color: #667eea;
  font-size: 1.5rem;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 2px solid #667eea;
}

.guide-section h3 {
  color: #555;
  font-size: 1.2rem;
  margin-top: 25px;
  margin-bottom: 15px;
}

.content-box {
  background: #f9f9f9;
  padding: 20px;
  border-radius: 8px;
  border-left: 4px solid #667eea;
}

.webgl-features {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.feature-item {
  background: white;
  padding: 15px;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
}

.feature-item h4 {
  color: #667eea;
  margin-bottom: 10px;
  font-size: 1.1rem;
}

.feature-item ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.feature-item li {
  padding: 5px 0;
  color: #555;
  font-size: 0.9rem;
}

.comparison-table {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin: 20px 0;
}

.comparison-item {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border: 2px solid #e0e0e0;
}

.comparison-item h4 {
  color: #667eea;
  margin-bottom: 15px;
  text-align: center;
}

.comparison-item ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.comparison-item li {
  padding: 8px 0;
  border-bottom: 1px solid #f0f0f0;
  color: #555;
}

.comparison-item li:last-child {
  border-bottom: none;
}

.webgl-highlight {
  border-color: #667eea;
  background: rgba(102, 126, 234, 0.05);
}

.pipeline-diagram {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 30px 0;
  padding: 20px;
  background: white;
  border-radius: 8px;
  overflow-x: auto;
}

.pipeline-step {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 120px;
}

.step-number {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #667eea;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  margin-bottom: 10px;
}

.step-content {
  text-align: center;
}

.step-content h4 {
  color: #333;
  margin-bottom: 5px;
  font-size: 1rem;
}

.step-content p {
  color: #666;
  font-size: 0.9rem;
  margin: 0;
}

.arrow {
  font-size: 1.5rem;
  color: #667eea;
  font-weight: bold;
}

.shader-example pre {
  margin: 15px 0;
}

.texture-coords {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin: 20px 0;
}

.coord-example pre {
  margin: 0;
}

.coord-diagram {
  display: flex;
  align-items: center;
  justify-content: center;
}

.texture-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  width: 100px;
  height: 100px;
  background: #f0f0f0;
  border: 1px solid #ccc;
}

.grid-point {
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
  border: 1px solid #ccc;
  font-size: 0.7rem;
  color: #666;
}

.library-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.library-item {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
}

.library-item h4 {
  color: #667eea;
  margin-bottom: 10px;
  font-size: 1.1rem;
}

.library-item > p {
  color: #666;
  margin-bottom: 15px;
  font-size: 0.9rem;
}

.library-item ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.library-item li {
  padding: 5px 0;
  color: #555;
  font-size: 0.9rem;
  border-bottom: 1px solid #f0f0f0;
}

.library-item li:last-child {
  border-bottom: none;
}

.optimization-tips {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.tip-group {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
}

.tip-group h4 {
  color: #667eea;
  margin-bottom: 15px;
  font-size: 1.1rem;
}

.tip-group ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.tip-group li {
  padding: 8px 0;
  color: #555;
  border-bottom: 1px solid #f0f0f0;
  line-height: 1.5;
}

.tip-group li:last-child {
  border-bottom: none;
}

.code-block {
  background: #2d2d2d;
  color: #f8f8f2;
  padding: 20px;
  border-radius: 6px;
  overflow-x: auto;
  margin: 15px 0;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.6;
}

.code-block code {
  color: #f8f8f2;
}

@media (max-width: 768px) {
  .webgl-guide {
    padding: 15px;
  }

  .guide-header h1 {
    font-size: 1.5rem;
  }

  .webgl-features {
    grid-template-columns: 1fr;
  }

  .comparison-table {
    grid-template-columns: 1fr;
  }

  .pipeline-diagram {
    flex-wrap: wrap;
    gap: 10px;
  }

  .pipeline-step {
    min-width: 100px;
  }

  .texture-coords {
    grid-template-columns: 1fr;
  }

  .library-grid {
    grid-template-columns: 1fr;
  }

  .optimization-tips {
    grid-template-columns: 1fr;
  }

  .code-block {
    font-size: 12px;
    padding: 15px;
  }
}
</style>